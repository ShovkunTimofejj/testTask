private final Map<String, Document> documentStorage = new HashMap<>(); - внутрішнє сховище документів в пам’яті. Думав замість HashMap використовувати ConcurrentHashMap (воно було б потокобезпечне), 
але функціонал має бути не складним, тому вирішив залишити HashMap (вона більш популярна і її функціонал більш зрозумілий).

save() - перевіряє, якщо у документа немає ID або воно пусте, то генерує нове унікальне ID і зберігає документ в HashMap.
search() - фільтрує документи на основі критеріїв пошуку з SearchRequest. Використовує методи стрімів для фільтрації документів.
findById() - повертає документ за заданим ID, якщо він існує в сховищі.
Класи SearchRequest, Document, Author - без змін.

В класі Main перевіряв, чи працює програма, розумію, що треба було зробити все в одному класі, але вирішив не додавати метод main в клас DocumentManager, щоб не робити його дуже великим.

Також написав тести до всіх методів:
setUp() - створює новий екземпляр DocumentManager перед кожним тестом.
shouldSaveDocument() - перевіряє, що документ успішно зберігається і його ID генерується правильно.
shouldSearchDocuments() - перевіряє, що пошук документів за заданими критеріями працює правильно.
shouldReturnEmptyListForNonMatchingSearch() - перевіряє, що пошук за некоректними критеріями повертає пустий список.
shouldFindDocumentById() - перевіряє, що документ може бути знайдений за ID.
shouldReturnEmptyOptionalForNonExistentId() - перевіряє, що пошук за неіснуючим ID повертає пустий результат.

В pom.xml додані залежності для Lombok, JUnit тестів і AssertJ (для легшого читання тестів).

Також мені не дуже подобається вигляд методу search(), як на мене він вийшов досить великим. 
Я думав про те, щоб для більшої читабельності коду створити кілька методів і викликати їх у методі search(),
але вирішив залишити метод search() великим, він, хоч і великий, але достатньо зрозумілий.
